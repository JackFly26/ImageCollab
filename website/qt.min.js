class Point{constructor(x,y,data){this.x=x,this.y=y,this.userData=data}}class Rectangle{constructor(x,y,w,h){this.x=x,this.y=y,this.w=w,this.h=h}contains(point){return point.x>=this.x-this.w&&point.x<=this.x+this.w&&point.y>=this.y-this.h&&point.y<=this.y+this.h}intersects(range){return!(range.x-range.w>this.x+this.w||range.x+range.w<this.x-this.w||range.y-range.h>this.y+this.h||range.y+range.h<this.y-this.h)}}class Circle{constructor(x,y,r){this.x=x,this.y=y,this.r=r,this.rSquared=this.r*this.r}contains(point){let d;return Math.pow(point.x-this.x,2)+Math.pow(point.y-this.y,2)<=this.rSquared}intersects(range){let xDist=Math.abs(range.x-this.x),yDist=Math.abs(range.y-this.y),r=this.r,w=range.w,h=range.h,edges=Math.pow(xDist-w,2)+Math.pow(yDist-h,2);return!(xDist>r+w||yDist>r+h)&&(xDist<=w||yDist<=h||edges<=this.rSquared)}}class QuadTree{constructor(boundary,capacity){if(!boundary)throw TypeError("boundary is null or undefined");if(!(boundary instanceof Rectangle))throw TypeError("boundary should be a Rectangle");if("number"!=typeof capacity)throw TypeError("capacity should be a number but is a $ {\n              typeof capacity\n            }");if(capacity<1)throw RangeError("capacity must be greater than 0");this.boundary=boundary,this.capacity=capacity,this.points=[],this.divided=!1}subdivide(){let x=this.boundary.x,y=this.boundary.y,w=this.boundary.w/2,h=this.boundary.h/2,ne=new Rectangle(x+w,y-h,w,h);this.northeast=new QuadTree(ne,this.capacity);let nw=new Rectangle(x-w,y-h,w,h);this.northwest=new QuadTree(nw,this.capacity);let se=new Rectangle(x+w,y+h,w,h);this.southeast=new QuadTree(se,this.capacity);let sw=new Rectangle(x-w,y+h,w,h);this.southwest=new QuadTree(sw,this.capacity),this.divided=!0}insert(point){return!!this.boundary.contains(point)&&(this.points.length<this.capacity?(this.points.push(point),!0):(this.divided||this.subdivide(),this.northeast.insert(point)||this.northwest.insert(point)||this.southeast.insert(point)||this.southwest.insert(point)))}query(range,found){if(found||(found=[]),!range.intersects(this.boundary))return found;for(let p of this.points)range.contains(p)&&found.push(p);return this.divided&&(this.northwest.query(range,found),this.northeast.query(range,found),this.southwest.query(range,found),this.southeast.query(range,found)),found}}"undefined"!=typeof module&&(module.exports={Point:Point,Rectangle:Rectangle,QuadTree:QuadTree,Circle:Circle});